#include <Servo.h>

//SENSORES
#define infra_F A4
#define infra_mDr A0
#define infra_pDr A2
#define infra_mEs A1
#define infra_pEs A3

//SERVOS
Servo pata1;
Servo pata2;

int pinos [] = {infra_pEs, infra_mEs, infra_F, infra_mDr, infra_pDr};

int infVal [] = {0, 0, 0, 0, 0};

void frente() {
 //Laion vai para frente
 //Depois chama essa funçaõ nos switchs
  pata1.write(0);
  pata2.write(180);
}
void re(){
 //Laion vai para trás
  pata1.write(180);
  pata2.write(0);
}
void direita(){
 //Laion realiza uma curva suave para direita
  pata1.write(0);
  pata2.write(90);
}
void esquerda(){
 //Laion realiza uma curva suave para esquerda
  pata1.write(90);
  pata2.write(180);
}

void direita90(){
//Laion gira no sentido horário
  pata1.write(0);
  pata2.write(180);
}

void esquerda90(){
//Laion gira no sentido anti-horário
  pata1.write(180);
  pata2.write(0);
} 

void setup() {
  for (int i = 0; i < 5; i++)
    pinMode(pinos[i], INPUT);
  pata1.attach(10);  
  pata2.attach(11);
  Serial.begin(9600);
}

void loop() {
  //teste[0] = {int(digitalRead(infra_pEs))};//, digitalRead(infra_mEs), digitalRead(infra_F), digitalRead(infra_mDr), digitalRead(infra_pDr)};
  //teste [] = {digitalRead(infra_pEs), digitalRead(infra_mEs), digitalRead(infra_F), digitalRead(infra_mDr), digitalRead(infra_pDr)};
  /*
  for (int i = 0; i < 5; i++)
    if (analogRead(pinos[i]) > 110){
      infVal[i] = 1;
    }
    else{
      infVal[i] = 0;
    }*/

 //DEFINIÇÃO DOS VALORES MIN. DE LEITURA DE CADA PINO, PARA DIFERENCIAR PRETO E BRANCO
 if (analogRead(pinos[0]) > 700){ infVal[0] = 0; }else{ infVal[0] = 1; }
  if (analogRead(pinos[1]) > 700){ infVal[1] = 0; }else{ infVal[1] = 1; }
  if (analogRead(pinos[2]) > 700){ infVal[2] = 0; }else{ infVal[2] = 1; }
  if (analogRead(pinos[3]) > 700){ infVal[3] = 0; }else{ infVal[3] = 1; }
  if (analogRead(pinos[4]) > 700){ infVal[4] =0; }else{ infVal[4] = 1; }

  Serial.print(analogRead(infra_pEs));
  Serial.println(": pEs");
  Serial.print(analogRead(infra_mEs));
  Serial.println(": mEs");
  Serial.print(analogRead(infra_F));
  Serial.println(": F");
  Serial.print(analogRead(infra_mDr));
  Serial.println(": mDr");
  Serial.print(analogRead(infra_pDr));
  Serial.println(": pDr");

  byte leitura = 0;                           
  for (int i = 0; i < 5; i++)
    leitura |= digitalRead(pinos[i]) << i;
    //leitura |= infVal[i] << i;
  leitura = (~leitura) & 0b00011111;

 // Serial.println(digitalRead(infra_mDr));

  Serial.println(leitura, BIN);



  switch(leitura){
     //RETA
    case (0b01110): // frente e meios no preto
    case (0b00100):
      Serial.println("Frente");
      frente();
      break;
   
   //CURVA FECHADA PARA ESQUERDA
    case (0b11110): // esquerda e meios no preto
      Serial.println("Esquerda");
      esquerda90();
      break;
   
   //CURVA FECHADA PARA DIREITA
    case (0b01111): // direita e meios no preto
      Serial.println("Direita");
      direita90();
      break;
   
   //AJUSTE PARA DIREITA
    case (0b00110): // frente e meia direita no preto
      Serial.println("Meio Direita");
      direita();
      break;
       
   //AJUSTE PARA ESQUERDA
    case (0b01100): // frente e meia esquerda no preto
      Serial.println("Meio Esquerda");
      esquerda();
      break;
  
   //GAP
     case (0b01010): // meios no preto
      Serial.println("Meios");
      frente();
      break; 
   
   //INTERSECÇÃO SEM MARCAÇÃO
     case (0b11111): // todos no preto
      Serial.println("Cruzamento");
      frente();
      break;
    default:
      //Serial.println("Erro");
      break;
  }

  delay(500);
}
